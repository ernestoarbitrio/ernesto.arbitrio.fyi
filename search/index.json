[{"content":"Are you tired of jumping through hoops to run Python tests, especially in complex environments like Docker? Meet the Pytest Runner, a Visual Studio Code extension designed to make running Python tests a breeze. Whether you‚Äôre executing single tests, modules, or working with local and containerized setups, Pytest Runner streamlines your workflow for a faster, more intuitive testing experience.\nüíæ Source code\nInstall Pytest Runner Plugin Getting started with Pytest Runner is easy! Install the plugin directly from the Visual Studio Code Marketplace. Click the link to install it instantly. Once installed, you‚Äôll be ready to run Python tests effortlessly with just a few clicks or commands. Wanna know more? Continue reading üëá\nüöÄ Why Pytest Runner? Modern testing can feel cumbersome. Take my job as an example: most tests run in a Docker-based architecture, requiring me to manage remote interpreters and lengthy pytest identifiers like test_module.py::test_function. This process wasn‚Äôt just slow‚Äîit was frustrating. I created Pytest Runner to simplify testing, inspired by tools like pytest-vim.\nThis extension focuses on one goal: reducing friction in Python testing. With Pytest Runner, you can focus on writing great code while the extension handles the grunt work.\nüåü Features Run tests locally or in Docker: Execute individual tests or entire test modules effortlessly, using either local environments or Dockerized setups. Configuration checks: Optional inspection of setup.cfg or pyproject.toml files ensures your test files follow your project\u0026rsquo;s conventions. Customizable settings: Tailor pytest commands, options, and configurations to fit your unique workflow. üìã Configuration Check: An Extra Layer of Validation Pytest Runner checks your project‚Äôs configuration files when enabled. For example, given a pyproject.toml:\n1 2 3 4 5 [tool.pytest.ini_options] python_classes = [\u0026#34;Test\u0026#34;, \u0026#34;Describe\u0026#34;] python_functions = [\u0026#34;test_\u0026#34;, \u0026#34;it_\u0026#34;, \u0026#34;and_\u0026#34;, \u0026#34;but_\u0026#34;, \u0026#34;they_\u0026#34;] python_files = [\u0026#34;test_*.py\u0026#34;] testpaths = [\u0026#34;tests\u0026#34;] or a setup.cfg file like:\n1 2 3 4 5 6 [tool:pytest] python_classes = Test Describe python_files = test_*.py python_functions = test_ it_ they_ but_ and_it_ testpaths = tests If a test function doesn‚Äôt follow these naming conventions, Pytest Runner will halt and notify you with an error message.\nüõ†Ô∏è Requirements Pytest: The only hard requirement. Currently tested on macOS and Linux. ‚öôÔ∏è Extension Settings This extension offers several customizable settings:\npytest_runner.pytest_exec: Specifies the local pytest executable. Defaults to your active virtual environment or /usr/bin/pytest. pytest_runner.pytest_exec_docker: Command to run pytest in a Docker container (e.g., docker-compose run \u0026ndash;rm test-container pytest). pytest_runner.check_config: Enables/disables configuration checks (default: false). pytest_runner.pytest_options: Additional pytest options (e.g., -sv, -x). These options can be set in each settings.json within .vscode in the project root directory or in the settings.json of VSCode (not recommended).\nFile example:\n1 2 3 4 5 { \u0026#34;pytest_runner.pytest_exec\u0026#34;: \u0026#34;./venv/bin/pytest\u0026#34;, \u0026#34;pytest_runner.pytest_exec_docker\u0026#34;: \u0026#34;docker-compose -f docker-compose.testing.yml run --rm testrunner_container pytest\u0026#34;, \u0026#34;pytest_runner.pytest_options\u0026#34;: \u0026#34;-vx\u0026#34;, } üéØ Usage Commands Run Test: Execute a single test locally. Run Test Docker: Execute a single test in Docker. Run Test Module: Run all tests in the current file locally. Run Test Module Docker: Run all tests in the current file via Docker. Access these commands via the VSCode command palette (‚áß‚åòP or Ctrl+‚áßP) or use the custom buttons in the status bar. Access these commands via the VSCode command palette (‚áß‚åòP or Ctrl+‚áßP) or use the custom buttons in the status bar.\n‚ñ∂Ô∏è Running Tests Place your cursor within a test function or class to execute it directly. Alternatively, select the test name or a portion of it and run the desired command. For module-level tests, use the appropriate command regardless of cursor location.\nüí° Pro Tip: Create keyboard shortcuts for frequently used commands to save time!\n‚å®Ô∏è Keybindings Define shortcuts for a more productive workflow:\n1 2 3 4 5 6 7 8 { \u0026#34;key\u0026#34;: \u0026#34;ctrl+alt+1\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;pytest-runner.run-test\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;ctrl+alt+2\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;pytest-runner.run-module-test\u0026#34; } Run single tests with Ctrl+Alt+1 and module tests with Ctrl+Alt+2 (or any combination you prefer).\nInstall Pytest Runner üíæ Install pytest runner\n","date":"2024-12-09T12:52:43+01:00","image":"https://ernesto.arbitrio.fyi/p/boost-your-python-testing-workflow-with-the-pytest-runner-vs-code-extension/cover_hu8424268574262894937.png","permalink":"https://ernesto.arbitrio.fyi/p/boost-your-python-testing-workflow-with-the-pytest-runner-vs-code-extension/","title":"Boost Your Python Testing Workflow with the Pytest Runner VS Code Extension"},{"content":"It can happen that, sometimes, you need a CLI for you application, and maybe could be nice to have a custom interactive shell with command completion and history. Python has the Cmd class within the cmd module that provides a simple framework for writing line-oriented command interpreters.\nThe skeleton of the shell 1 2 3 4 5 6 from cmd import Cmd class MyPrompt(Cmd): pass MyPrompt().cmdloop() The Cmd.cmdloop() repeatedly issue a prompt, accept input, parse an initial prefix off the received input, and dispatch to action methods, passing them the remainder of the line as argument.\nBasically when we run the script above it will display a default prompt:\n1 2 (Cmd) The ``Cmd`` includes the ``help`` or ``?`` command to get your interactive shell help: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (Cmd) help Documented commands (type help \u0026lt;topic\u0026gt;): ======================================== help (Cmd) ? Documented commands (type help \u0026lt;topic\u0026gt;): ======================================== help (Cmd) If you would like to exit the application you need to press ``Ctlr-C`` and get a ``KeyboardInterrupt``. Prompt and Intro The default prompt text is (Cmd) but it can be overridden using the prompt attribute of the class.\nFurthermore we can set a text to be the banner (or the welcome message for example), that is the text message shown when we launch our application.\n1 2 3 4 5 6 7 8 from cmd import Cmd class MyPrompt(Cmd): prompt = \u0026#34;myshell\u0026gt;\u0026#34; intro = \u0026#34;Welcome!! Type ? or help for the commands list.\u0026#34; pass MyPrompt().cmdloop() Complete example Now I\u0026rsquo;d like to show you a complete example of a custom interactive shell. Imagine you wanna create a command to compute a sum of bunch of numbers (e.g. 1,4,5,78,23).\nI\u0026rsquo;m gonna create a do_sum method that will compute the sum of the numbers.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from cmd import Cmd class MyPrompt(Cmd): prompt = \u0026#34;myshell\u0026gt; \u0026#34; intro = \u0026#34;Welcome to MY shell! Type ? to list commands\u0026#34; def onecmd(self, line): try: return super().onecmd(line) except Exception as e: print(f\u0026#34;{e}\u0026#34;) return False # don\u0026#39;t stop def do_exit(self, inp): print(\u0026#34;Bye\u0026#34;) return True def help_exit(self): print(\u0026#34;exit the application. Shorthand: x q Ctrl-D.\u0026#34;) def default(self, inp): if inp == \u0026#34;q\u0026#34;: return self.do_exit(inp) print(\u0026#34;Default: {}\u0026#34;.format(inp)) def help_sum(self): print(\u0026#34;Run a sum\u0026#34;) def do_sum(self, input): lst_input = [int(n) for n in input.split(\u0026#34;,\u0026#34;)] print(f\u0026#34;The sum is: {sum(lst_input)}\u0026#34;) do_EOF = do_exit help_EOF = help_exit if __name__ == \u0026#34;__main__\u0026#34;: MyPrompt().cmdloop() and see it in action:\n1 2 3 4 5 6 ~ python -m shell Welcome to MY shell! Type ? to list commands myshell\u0026gt; sum 1,2,3,4,5 The sum is: 15 myshell\u0026gt; sum \u0026#34;a,dsfg\u0026#34; invalid literal for int() with base 10: \u0026#39;\u0026#34;a\u0026#39; As you can see the first command return a valid and meaningful output. The second one fails due to the wrong output and it returns the error trace of the python interpreter. That\u0026rsquo;s nice huh? üòé\nTaking a look at the code snippet above you can notice the onecmd method within the MyPromopt class.\n1 2 3 4 5 6 def onecmd(self, line): try: return super().onecmd(line) except Exception as e: print(f\u0026#34;{e}\u0026#34;) return False # don\u0026#39;t stop That method, that extends the one of the super class, is called when the user enters a command, and in case of an exception print the exception. This is a very useful feature to have when you are developing a command line application because in case of an error whatsoever, it won\u0026rsquo;t crash the application, and you can decide you custom fallback action.\nThe other method default is called every time a command is entered and it does not correspond to any of the do_* methods.\nWhat about the do_EOF and help_EOF? You might have noticed that Ctrl-d, prints *** Unknown syntax: EOF. That\u0026rsquo;s because Ctrl-d send an EOF (End Of File) signal and by default Cmd does not know what to do with it.\nThe solution is to implement the do_EOF method that will be called when the user presses Ctl-d. As we already have a do_exit method, we can just assign that to the do_EOF and have both do the same. In order to provide help for the EOF, we can include a function called help_EOF that is assigned the help_exit function.\nIMHO this is a great built-in feature, very useful when you wanna create a command line application as a public interface of you library.\nOn top of the cmd module a lot of 3rd party apps have been created. I\u0026rsquo;d like to mention cmd2 that can be defined a custom cmd module with steroids üòÄ.\nI hope you enjoied this article! See you at next episode üëã.\n","date":"2022-01-19T12:52:43+01:00","image":"https://ernesto.arbitrio.fyi/p/create-your-custom-interactive-shell-with-python/cover_hu12935657283093393349.png","permalink":"https://ernesto.arbitrio.fyi/p/create-your-custom-interactive-shell-with-python/","title":"Create your custom interactive shell with python üêç"},{"content":"A Virtual Environment is a real good way to keep the dependencies required by different projects in separate places, by creating virtual Python environments for each of them. It solves the \u0026ldquo;Project X depends on version 1.x but, Project Y needs 4.x\u0026rdquo; dilemma, and keeps your global site-packages directory clean and manageable. For example, you can work on a project which requires matplotlib 1.5.3 while also maintaining a project which requires matplotlib 1.4.2.\nThere are different tools that can manage python virtual environment, those I will show are:\nvirtualenv anaconda (by continuum analytics) The first one is the most popular for general pourpose coding projects, anaconda is much more suitable for who works in data science field. In this post I would like to explain out how to install and use both of them to create your python virtualenv.\nVirtualenv When you run virtualenv command inside your shell, it creates a folder which contains all the necessary executables to use the packages that a Python project would need.\nTo install virtualenv via pip:\n1 pip install virtualenv To install python pip via s.o. package manager (ubuntu for instance):\n1 sudo apt-get install python-pip Basic usage Create a firt virtual environment for your project:\n1 2 cd my_venv_dir virtualenv myproject virtualenv myproject will create a folder in the directory you are which will contain the Python executable files, and a copy of the pip library which you can use to install other packages. Usually I do not create the virtual environment within the source code directory in order to keep venv and code separate. In this way I don't need to exclude the virtualenv directory from the version control system I will use for software versioning.\nIn your virtualenvironment directory you shuold have something like this:\n1 2 3 4 5 6 $ ls -la drwxr-xr-x 16 user staff 544 May 15 06:33 bin drwxr-xr-x 3 user staff 102 May 15 06:30 include drwxr-xr-x 4 user staff 136 May 15 06:33 lib -rw-r--r-- 1 user staff 60 May 15 06:33 pip-selfcheck.json You can also use the Python interpreter of your choice (like python2.7).\n1 virtualenv -p /usr/local/bin/python2 myproject Naturally you need change the python 2 path with yours.\nTo begin using the virtual environment, it needs to be activated:\n1 source /myproject/bin/activate The name of the current virtual environment will now appear as prefix of the prompt (e.g. $(myproject)username@yourcomputer) to let you know that it\u0026rsquo;s active. From now on, any package that you install using pip will be placed in the myproject folder, in this way the global Python installation will remain clean.\nInstall packages as usual:\n1 pip install matplotlib If you want to deactivate your virtualenv with:\n1 deactivate This puts you back to the system\u0026rsquo;s default Python interpreter with all its installed libraries.\nTo delete a virtual environment, just delete the folder. (In this case, it would be rm -rf myproject.)\nAfter a while, though, you might end up with a lot of virtual environments littered across your system, and its possible you\u0026rsquo;ll forget their names or where they were placed.\nExtra commands In order to keep your environment consistent, it\u0026rsquo;s a good idea to \u0026ldquo;freeze\u0026rdquo; the current state of the environment packages. To do this, run\n1 pip freeze \u0026gt; requirements.txt This will create a requirements.txt file, which contains a list of all the packages in the current environment, and their respective versions. You can see the list of installed packages without the requirements format using pip list. Later it will be easier for a different developer (or you, if you need to re-create the environment) to install the same packages using the same versions:\n1 pip install -r requirements.txt Remember to add the requirements file in your current project directory; this can help ensure consistency across installations, across deployments, and across developers.\nNow let's take a look to the packages you need for starting a new virtual environment for data analytics projects. The most used by me are: numpy, pandas, matplotlib, jupyter notebook, scipy; naturaly each of you can use those who prefer.\nAs you can see in the previous paragraphs to install a python lib in a virtualenv you may use pip command; to install each package there are 2 simple ways: install them one by one or create a requirements.txt file with one library per line:\n1 2 3 4 5 numpy pandas matplotlib jupyter scipy or if you want you can specify the version if you want to avoid the installation of the latest stable release of the softwares:\n1 2 3 4 5 numpy==1.10 pandas==0.18.1 jupyter matplotlib==1.5.1 scipy Now pip install -r requirements.txt will install all your software and the related dependencies; and your data science oriented virtualenv is now ready to go.\nThe Anaconda¬© python distribution From my personal point of view, a more appropriate way than using virtualenv is to adopt the Anaconda platform. Anaconda is the leading open data science platform powered by Python. The open source version of Anaconda is a high performance distribution of Python and R and includes over 100 of the most popular Python, R and Scala packages for data science.\nAdditionally, you'll have access to over 720 packages that can easily be installed with conda, our renowned package, dependency and environment manager, that is included in Anaconda.\nIf you're interesting on \u0026quot;Why should I use Anaconda?\u0026quot; I may suggest you to read:\nhttps://www.continuum.io/why-anaconda https://www.reddit.com/r/Python/comments/3t23vv/what_advantages_are_there_of_using_anaconda The two principal advantages more useful in my own experience are the user level install of the version of python you want and the \u0026quot;batteries included\u0026quot; for data science (e.g. numpy, scipy, PyQt, spyder IDE, etc.)\nInstall Anaconda is very simple, just download the rigth package for your O.S. and use the instructions on the page to install it in the proper way.\nFor instance if you use Linux or Mac OSX:\n1 bash Anaconda-v-0.x.y.sh and follow the instructions on the screen. Note that during the Anaconda installation process it will ask you to add a directive in your bash profile to change your default python path. In this way Anaconda python distribution will be your new python ecosystem, otherwise if you answer no to use the Anaconda python you have to select the python executable by hand.\nNow that Anaconda is installed you are able to create a new conda environment or anyway you can use the root env with a lot of packages. Let's see how to create a conda env now:\n1 2 3 4 5 conda create -n envname # if you want to pass a specific python version conda create -n envname python=2.7 Once the env is created you may activate it\n1 source activate envname This should procude something like this:\n1 2 3 4 5 6 7 8 9 (envname) user@hostname$ # check your python version (envname) user@hostname$ python Python 3.5.2 |Continuum Analytics, Inc.| (default, Jul 2 2016, 17:52:12) [GCC 4.2.1 Compatible Apple LLVM 4.2 (clang-425.0.28)] on darwin Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; Now, as used with the [virtualenv]{.title-ref} tool we can install the packages we need in our conda env with the conda command.\n1 (envname) user@hostname$ conda install pandas # e.g. install pandas package Managing the environments is quite easy, there are several options to use with conda command; here a good cheatsheet with all the reference you need.\nRemember that Anaconda is batteries included so it's possible you have all the packages you need in the root env. Without create or activate any environment try to check the library installed in your conda root instance, you should have something like this\n1 2 3 4 5 6 7 8 9 10 user@hostname$ conda list ... ruamel_yaml 0.11.14 py35_0 sasl 0.2.1 \u0026lt;pip\u0026gt; scikit-image 0.12.3 np111py35_1 scikit-learn 0.17.1 np111py35_2 scipy 0.18.1 np111py35_0 scp 0.10.2 \u0026lt;pip\u0026gt; seaborn 0.7.1 \u0026lt;pip\u0026gt; ... As you can notice some packages in the previous snippet are installed via pip, this means that with anaconda and within any conda env you can use also the pip command to get the python modules you want.\nImport and Export a conda environment To enable other people to create an exact copy of your environment, you can export the active environment file.\nActivate the environment you wish to export:\nLinux, OS X: source activate envname\nwindows: activate envname\nNow export your env to new declarative file:\nconda env export \u0026gt; environment.yml\nNOTE: If you already have an environment.yml file in you current directory, it will be overwritten with the new file.\nIf you instead of exporting your env you want to create a new conda environment from an .yml file:\nconda env create -f environment.yml\nThe enviromnent files can be created by hand just beeing compliant with some basic ruels. For instance if you want to set your dependencies these are the rules to follow:\n1 2 3 4 5 env_name: stats dependencies: - numpy - pandas - scipy and then save your file with the name you want.\nUnlike pip, conda is language-agnostic, this permit you to use the R language in your conda environment, and obviously create R based notebooks with jupyter.\nThe Anaconda team has created an \u0026ldquo;R Essentials\u0026rdquo; bundle with the IRKernel and over 80 of the most used R packages for data science, including dplyr, shiny, ggplot2, tidyr,caret and nnet.\nDownloading \u0026ldquo;R Essentials\u0026rdquo; requires conda. Miniconda includes conda, Python, and a few other necessary packages, while Anaconda includes all this and over 200 of the most popularPython packages for science, math, engineering, and data analysis. Users may install all of Anaconda at once, or they may install Miniconda at first and then use conda to install any other packages they need, including any of the packages in Anaconda.\nOnce you have conda, you may install \u0026ldquo;R Essentials\u0026rdquo; into the current environment:\n1 conda install -c r r-essentials and now starting jupyter notebook from your virtual environment $ jupyter notebook you are able to create a new R notebook:\nReferences Part of this post is inspired by:\nhttps://www.continuum.io/blog/developer/jupyter-and-conda-r http://python-guide-pt-br.readthedocs.io/en/latest/dev/virtualenvs/ ","date":"2018-06-19T00:00:00Z","permalink":"https://ernesto.arbitrio.fyi/p/understanding-and-use-python-virtualenvs-from-data-scientist-perspective/","title":"Understanding and use python virtualenvs from Data Scientist perspective"}]